#!/bin/python3

import sys
import configparser
from pathlib import Path
from datetime import datetime

import spotipy
from spotipy.oauth2 import SpotifyOAuth

CWD = str(Path(__file__).parent)
CONFIG = configparser.ConfigParser()
CONFIG.read(CWD + "/config.ini")
USER = CONFIG["spotify"]["user"]
CLIENT_ID = CONFIG["spotify"]["client_id"]
CLIENT_SECRET = CONFIG["spotify"]["client_secret"]
REDIRECT_URI = CONFIG["spotify"]["redirect_uri"]
SCOPE = CONFIG["spotify"]["scope"]
GENIUS_TOKEN = CONFIG["genius"]["token"]
CACHE_PATH = CWD + "/.cache"
MAX_SONGS_TO_PROMPT = 100
API_SONGS_LIMIT = 100

genius_client = None
if GENIUS_TOKEN and "-ng" not in sys.argv and "--no-genius" not in sys.argv:
    from genius import Genius
    genius_client = Genius(GENIUS_TOKEN)

spotify_client = spotipy.Spotify(
        auth_manager=SpotifyOAuth(
            client_id=CLIENT_ID,
            client_secret=CLIENT_SECRET,
            redirect_uri=REDIRECT_URI,
            scope=SCOPE,
            cache_path=CACHE_PATH
        )
    )
album_cache = {}


def update_cache(song, release_date):
    album_name = "{} {}".format(song["album"], song["artist"])
    album_cache[album_name] = release_date


def get_song_release_date(song, logs=False):
        album_name = "{} {}".format(song["album"], song["artist"])
        if album_name in album_cache:
            return album_cache[album_name]

        elif song["release_date"] and len(song["release_date"].split("-")) == 3 and "-1-1" not in song["release_date"].split("-"):
            # Most of release date placeholder are year-only (e.g.: 1997) or 1 January (2004-1-1)
            # Also, local songs don't have a release date so we have to check it
            year, month, day = song["release_date"].split("-")
            return datetime(int(year), int(month), int(day))

        elif genius_client:
            match_list = list(genius_client.search(song["name"], page=1, per_page=5))
            for match in match_list:
                if match.album and match.album.name == song["album"]:
                    return match.release_date

        if logs and genius_client:
            print("<< Couldn't find an accurate release date on Spotify and Genius for >>")
            print("{} (setted automatically on {}-1-1)".format(song["name"], song["release_date"]))
        if song["release_date"]:
            return datetime(int(song["release_date"]), 1, 1)
        # If it's impossible to find a local song release date on Genius, that track is put at the end of the playlist
        # Unless you listen some Beethoven shit
        return datetime(1800, 1, 1)


def get_song_new_position(song, playlist_songs, songs_to_sort):
    song_release_date = get_song_release_date(song, logs=True)
    album_found = False

    for index in range(len(playlist_songs)):
        current_playlist_song = playlist_songs[index]

        if current_playlist_song == song or current_playlist_song in songs_to_sort:
            continue

        # Same album, just check track number (and disc number for double disc albums)
        elif song["album"] == current_playlist_song["album"]:
            album_found = True
            if song["disc_number"] == current_playlist_song["disc_number"] and song["track_number"] < current_playlist_song["track_number"]:
                return index

        # Exit from album, it's certainly the last track of the album among those added
        elif album_found:
            return index

        else:
            current_playlist_song_release_date = get_song_release_date(current_playlist_song)
            update_cache(current_playlist_song, current_playlist_song_release_date)
            if song_release_date > current_playlist_song_release_date:
                return index

    return index + 1


def sort_playlist(playlist_id, playlist_songs, songs_to_sort):
    total = len(songs_to_sort)
    while songs_to_sort:
        song = songs_to_sort.pop()
        # The final combination of character move the cursor at the beginning of line
        print(":: Sorting ({}/{})\033[A\033[2D".format(total - len(songs_to_sort), total))
        song_start_position = playlist_songs.index(song)
        song_new_position = get_song_new_position(song, playlist_songs, songs_to_sort)
        spotify_client.playlist_reorder_items(
            playlist_id=playlist_id,
            range_start=song_start_position,
            insert_before=song_new_position
        )
        playlist_songs.remove(song)
        playlist_songs.insert(song_new_position, song)


def choose_songs_to_sort(playlist_songs, choice):
    if choice == "all":
        return playlist_songs.copy()
    res = []
    for group in choice.split(" "):
        if group:
            start = int(group.split("-")[0])
            end = int(group.split("-")[-1]) + 1
            for i in range(start, end):
                res.append(playlist_songs[-i])
    return res


def last_songs_of_playlist_prompt(last_songs):
    lines = [f":: Last {MAX_SONGS_TO_PROMPT} songs of this playlist"]
    # Reverse order for a better view
    for index, song in zip(range(len(last_songs), 0, -1), last_songs):
        lines.append("{:<5}{} - {}".format(index, song["artist"], song["name"]))
    lines.append("==> Songs to sort (eg: \"1 2 3\", \"1-4\", or \"all\"):")
    lines.append("==> ")
    return "\n".join(lines)


def get_playlist_songs(spotify_client, playlist_id, playlist_length):
    songs = []
    offset = 0
    for offset in range(0, playlist_length, API_SONGS_LIMIT):
        # We increment offset because the maximum value of limit is 100
        playlist_items = spotify_client.playlist_items(playlist_id, limit=API_SONGS_LIMIT, offset=offset)["items"]
        for item in playlist_items:
            songs.append({
                "id": item["track"]["id"],
                "name": item["track"]["name"],
                "artist": item["track"]["artists"][0]["name"],
                "album": item["track"]["album"]["name"],
                "release_date": item["track"]["album"]["release_date"],
                "track_number": item["track"]["track_number"],
                "disc_number": item["track"]["disc_number"]
            })
    return songs


def all_user_playlists_prompt(user_playlists):
    lines = [":: Your playlists"]
    # Reverse order for a better view
    for index, playlist in zip(range(len(user_playlists), 0, -1), user_playlists[::-1]):
        lines.append("{:<5}{}".format(index, playlist["name"]))
    lines.append("==> Choose the playlist to sort (eg: \"1\" or \"2\"): ")
    lines.append("==> ")
    return "\n".join(lines)


def main():
    user_playlists = spotify_client.current_user_playlists()["items"]
    print(all_user_playlists_prompt(user_playlists), end="")
    playlist = user_playlists[int(input()) - 1]

    playlist_songs = get_playlist_songs(spotify_client, playlist["id"], playlist["tracks"]["total"])
    print(last_songs_of_playlist_prompt(playlist_songs[-MAX_SONGS_TO_PROMPT:]), end="")
    songs_to_sort = choose_songs_to_sort(playlist_songs, input())

    sort_playlist(playlist["id"], playlist_songs, songs_to_sort)

    print("\nOperation completed!")


if __name__ == "__main__":
    main()
